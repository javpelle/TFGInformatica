/**
 * This code is part of MTQC.
 * 
 * Copyright (c) 2020 Javier Pellejero, Luis Aguirre.
 * 
 * This code is licensed under the MIT License. You may obtain a copy 
 * of this license in the LICENSE file in the root directory of this source tree 
 * or at https://github.com/javpelle/TFGInformatica/blob/master/LICENSE.
 */

package model;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;

import exception.EmptyListException;
import exception.NullStringException;
import exception.ShotsException;
import exception.TimeLimitException;
import javafx.util.Pair;
import model.mutant.Mutant;
import model.mutantoperator.MutantOperator;
import model.mutantoperator.qiskit.CCXCSWAPGate;
import model.mutantoperator.qiskit.CHSWAPGate;
import model.mutantoperator.qiskit.CHXGate;
import model.mutantoperator.qiskit.CHYGate;
import model.mutantoperator.qiskit.CHZGate;
import model.mutantoperator.qiskit.CSWAPCCXGate;
import model.mutantoperator.qiskit.CXHGate;
import model.mutantoperator.qiskit.CXSWAPGate;
import model.mutantoperator.qiskit.CXYGate;
import model.mutantoperator.qiskit.CXZGate;
import model.mutantoperator.qiskit.CYHGate;
import model.mutantoperator.qiskit.CYSWAPGate;
import model.mutantoperator.qiskit.CYXGate;
import model.mutantoperator.qiskit.CYZGate;
import model.mutantoperator.qiskit.CZHGate;
import model.mutantoperator.qiskit.CZSWAPGate;
import model.mutantoperator.qiskit.CZXGate;
import model.mutantoperator.qiskit.CZYGate;
import model.mutantoperator.qiskit.HXGate;
import model.mutantoperator.qiskit.HYGate;
import model.mutantoperator.qiskit.HZGate;
import model.mutantoperator.qiskit.RXYGate;
import model.mutantoperator.qiskit.RXZGate;
import model.mutantoperator.qiskit.RYXGate;
import model.mutantoperator.qiskit.RYZGate;
import model.mutantoperator.qiskit.RZXGate;
import model.mutantoperator.qiskit.RZYGate;
import model.mutantoperator.qiskit.SSdgGate;
import model.mutantoperator.qiskit.STGate;
import model.mutantoperator.qiskit.SWAPCHGate;
import model.mutantoperator.qiskit.SWAPCXGate;
import model.mutantoperator.qiskit.SWAPCYGate;
import model.mutantoperator.qiskit.SWAPCZGate;
import model.mutantoperator.qiskit.SZGate;
import model.mutantoperator.qiskit.SdgSGate;
import model.mutantoperator.qiskit.SdgTGate;
import model.mutantoperator.qiskit.SdgZGate;
import model.mutantoperator.qiskit.TSGate;
import model.mutantoperator.qiskit.TSdgGate;
import model.mutantoperator.qiskit.TZGate;
import model.mutantoperator.qiskit.XHGate;
import model.mutantoperator.qiskit.XYGate;
import model.mutantoperator.qiskit.XZGate;
import model.mutantoperator.qiskit.YHGate;
import model.mutantoperator.qiskit.YXGate;
import model.mutantoperator.qiskit.YZGate;
import model.mutantoperator.qiskit.ZHGate;
import model.mutantoperator.qiskit.ZSGate;
import model.mutantoperator.qiskit.ZSdgGate;
import model.mutantoperator.qiskit.ZTGate;
import model.mutantoperator.qiskit.ZXGate;
import model.mutantoperator.qiskit.ZYGate;
import model.mutantoperator.qsharp.GateHX;
import model.mutantoperator.qsharp.GateHY;
import model.mutantoperator.qsharp.GateHZ;
import model.mutantoperator.qsharp.GateST;
import model.mutantoperator.qsharp.GateTS;
import model.mutantoperator.qsharp.GateXH;
import model.mutantoperator.qsharp.GateXY;
import model.mutantoperator.qsharp.GateXZ;
import model.mutantoperator.qsharp.GateYH;
import model.mutantoperator.qsharp.GateYX;
import model.mutantoperator.qsharp.GateYZ;
import model.mutantoperator.qsharp.GateZH;
import model.mutantoperator.qsharp.GateZX;
import model.mutantoperator.qsharp.GateZY;
import model.mutantoperator.qsharp.MissAdjoint;
import model.mutantoperator.qsharp.OneZero;
import model.mutantoperator.qsharp.PauliXY;
import model.mutantoperator.qsharp.PauliXZ;
import model.mutantoperator.qsharp.PauliYX;
import model.mutantoperator.qsharp.PauliYZ;
import model.mutantoperator.qsharp.PauliZX;
import model.mutantoperator.qsharp.PauliZY;
import model.mutantoperator.qsharp.RotXY;
import model.mutantoperator.qsharp.RotXZ;
import model.mutantoperator.qsharp.RotYX;
import model.mutantoperator.qsharp.RotYZ;
import model.mutantoperator.qsharp.RotZX;
import model.mutantoperator.qsharp.RotZY;
import model.mutantoperator.qsharp.ZeroOne;
import model.run.QSharp;
import model.run.Qiskit;
import model.test.OutputTest;
import model.test.ProbabilityTest;
import model.test.Test;
import model.testresult.TestResult;

/**
 * Model class for the MVC
 * 
 * @author Javier & Luis
 *
 */
public class Model implements Observable<Observer> {

	/**
	 * Observer.
	 */
	private Observer observer;

	/**
	 * Boolean used to check if Qiskit Language is selected.
	 */
	private boolean qiskit;

	/**
	 * Absolute path where the program is being executed.
	 */
	private String path;

	/**
	 * Relative path to temporally store all the mutants generated by the program.
	 */
	private static final String mutantPath = ".mutants";

	/**
	 * Conficende parameter.
	 */
	private double confidence;

	/**
	 * Used to store all the results gathered in the execution.
	 */
	private ArrayList<ArrayList<TestResult>> results;

	/**
	 * Initializes all possible mutant operators for Qiskit language.
	 */
	private MutantOperator[] qiskitOperators = { new CCXCSWAPGate(), new CHSWAPGate(), new CHXGate(), new CHYGate(),
			new CHZGate(), new CSWAPCCXGate(), new CXHGate(), new CXSWAPGate(), new CXYGate(), new CXZGate(),
			new CYHGate(), new CYSWAPGate(), new CYXGate(), new CYZGate(), new CZHGate(), new CZSWAPGate(),
			new CZXGate(), new CZYGate(), new HXGate(), new HYGate(), new HZGate(), new RXYGate(), new RXZGate(),
			new RYXGate(), new RYZGate(), new RZXGate(), new RZYGate(), new SdgSGate(), new SdgTGate(), new SdgZGate(),
			new SSdgGate(), new STGate(), new SWAPCHGate(), new SWAPCXGate(), new SWAPCYGate(), new SWAPCZGate(),
			new SZGate(), new TSdgGate(), new TSGate(), new TZGate(), new XHGate(), new XYGate(), new XZGate(),
			new YHGate(), new YXGate(), new YZGate(), new ZHGate(), new ZSdgGate(), new ZSGate(), new ZTGate(),
			new ZXGate(), new ZYGate() };

	/**
	 * Initializes all possible mutant operators for QSharp language.
	 */
	private MutantOperator[] qsharpOperators = { new GateHX(), new GateHY(), new GateHZ(), new GateST(), new GateTS(),
			new GateXH(), new GateXY(), new GateXZ(), new GateYH(), new GateYX(), new GateYZ(), new GateZH(),
			new GateZX(), new GateZY(), new MissAdjoint(), new OneZero(), new PauliXY(), new PauliXZ(), new PauliYX(),
			new PauliYZ(), new PauliZX(), new PauliZY(), new RotXY(), new RotXZ(), new RotYX(), new RotYZ(),
			new RotZX(), new RotZY(), new ZeroOne() };

	/**
	 * Initializes both type of test available.
	 */
	private Test[] tests = { new ProbabilityTest(), new OutputTest() };

	/**
	 * Used to store all mutants generated by the program.
	 */
	private ArrayList<Mutant> mutantList;

	/**
	 * Empty constructor for the class.
	 */
	public Model() {
		confidence = 1.0;
		qiskit = false;
		mutantList = new ArrayList<Mutant>();
	}

	/**
	 * Notifies the observer that some error occurred, and throw an exception as
	 * well.
	 */
	public void notifyError(Exception e) {
		String msg = e.getLocalizedMessage();
		observer.onError(msg);
	}

	/**
	 * Notifies the observer that some error occurred.
	 */
	public void notifyError(String msg) {
		observer.onError(msg);
	}

	/**
	 * Notifies the observer that the language has changed.
	 */
	public void notifyLanguageChange() {
		if (qiskit) {
			observer.updateMutantOperators(qiskitOperators, true);
		} else {
			observer.updateMutantOperators(qsharpOperators, false);
		}
	}

	@Override
	public void addObserver(Observer o) {
		observer = o;
	}

	@Override
	public void removeObserver(Observer o) {
		observer = null;
	}

	/**
	 * Starts the model.
	 */
	public void start() {
		updatePath(System.getProperty("user.dir"));
		updateMutantOperators(qiskit);
		observer.setTests(tests);
	}

	/**
	 * Resets the model to the initial state.
	 */
	public void reset() {
		removeMutants();
		mutantList = new ArrayList<Mutant>();
		start();
		observer.updateMutants(mutantList);
		observer.updateFileMethods(new ArrayList<String>(), mutantList);
	}

	/**
	 * Updates the mutants operators available for a language.
	 * 
	 * @param qiskit Indicates whether qiskit is selected or not.
	 */
	public void updateMutantOperators(boolean qiskit) {
		this.qiskit = qiskit;
		updatePath(path);
		notifyLanguageChange();
	}

	/**
	 * Updates to new path and notifies the UI
	 * 
	 * @param path New path.
	 */
	public void updatePath(String path) {
		this.path = path;
		ArrayList<String> files = new ArrayList<String>();
		File folder = new File(path);
		File[] listOfFiles = folder.listFiles();
		String extension;
		if (qiskit) {
			extension = ".py";
		} else {
			extension = ".qs";
		}
		for (int i = 0; i < listOfFiles.length; i++) {
			if (listOfFiles[i].isFile() && listOfFiles[i].getName().endsWith(extension)
					&& !listOfFiles[i].getName().startsWith("._")) {
				files.add(listOfFiles[i].getName());
			}
		}
		observer.updatePath(files);
	}

	/**
	 * Aplies all posible mutant operations to a set of files.
	 * 
	 * @param files     Set of files.
	 * @param operators Mutant operators wanted to be aplied.
	 */
	public void generate(ArrayList<String> files, ArrayList<MutantOperator> operators) {
		if (files.isEmpty()) {
			observer.notifyMutantsGenerator("No files selected!\n");
		} else if (operators.isEmpty()) {
			observer.notifyMutantsGenerator("No operators selected!\n");
		} else {
			File file = new File(mutantPath);
			file.mkdir();
			for (int i = 0; i < files.size(); i++) {
				for (int j = 0; j < operators.size(); j++) {
					mutantList.addAll(applyOperatorToFile(files.get(i), operators.get(j)));
				}
			}
			observer.notifyMutantsGenerator(
					"Completed. " + String.valueOf(mutantList.size()) + " mutants generated!\n");
			observer.updateMutants(mutantList);
		}
	}

	/**
	 * Aplies a particular mutant operator to a particular file. We only aply 1
	 * operator at a time.
	 * 
	 * @param filePath       Name of the file.
	 * @param mutantOperator Mutant operator to be aplied.
	 * @return
	 */
	private ArrayList<Mutant> applyOperatorToFile(String filePath, MutantOperator mutantOperator) {
		ArrayList<Mutant> auxList = new ArrayList<Mutant>();
		String searchWord = mutantOperator.getSearchOperator();
		String replaceWord = mutantOperator.getMutantOperator();
		String completeFilePath = path + File.separator + filePath;
		File originalFile = new File(completeFilePath);
		String file = "";
		BufferedReader reader = null;
		ArrayList<Pair<Integer, Integer>> lineOffset = new ArrayList<Pair<Integer, Integer>>();
		int lineCount = 1;
		int totalOffset = 0;

		try {
			reader = new BufferedReader(new FileReader(originalFile));
			String line = reader.readLine();

			while (line != null) {
				line = " " + line;
				for (int offset = 1; offset < line.length(); offset++) {
					if (line.startsWith(searchWord, offset) && (qiskit || mutantOperator
							.checkRegEx(line.substring(offset - 1, offset + searchWord.length() + 1)))) {
						lineOffset.add(new Pair<Integer, Integer>(lineCount, totalOffset + offset - 1));
					}
				}

				file = file + line.substring(1) + System.lineSeparator();
				totalOffset = file.length();
				lineCount++;
				line = reader.readLine();
			}

			StringBuilder fileBuilder = new StringBuilder(file);
			File saveFile;
			BufferedWriter writer = null;
			for (int i = 0; i < lineOffset.size(); i++) {

				fileBuilder.delete(lineOffset.get(i).getValue(), lineOffset.get(i).getValue() + searchWord.length());
				fileBuilder.insert(lineOffset.get(i).getValue(), replaceWord);
				String name = "_" + Integer.toString(i) + "_" + mutantOperator.getName() + "_" + filePath;
				String filePathWrite = mutantPath + File.separator + name;
				saveFile = new File(filePathWrite);
				try {
					writer = new BufferedWriter(new FileWriter(saveFile));
					writer.write(fileBuilder.toString());
				} finally {
					if (writer != null)
						writer.close();
				}
				auxList.add(new Mutant(name, path, filePath, mutantPath, name, lineOffset.get(i).getKey()));

				// Devolvemos la estructura general de fileBuilder.

				fileBuilder.delete(lineOffset.get(i).getValue(), lineOffset.get(i).getValue() + replaceWord.length());
				fileBuilder.insert(lineOffset.get(i).getValue(), searchWord);
			}
		} catch (

		IOException e) {
			notifyError(e);
			e.printStackTrace();
		} finally {
			try {
				reader.close();
			} catch (IOException e) {
				notifyError(e);
				e.printStackTrace();
			}
		}
		return auxList;
	}

	/**
	 * Deletes the files generated during mutation process.
	 */
	public void removeMutants() {
		for (Mutant m : mutantList) {
			try {
				File f = new File(m.getMutantCompletePath()); // file to be delete
				f.delete();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	/**
	 * Updates the path to check new files.
	 */
	public void refreshPath() {
		updatePath(path);
	}

	/**
	 * Gets the name of all methods in a file.
	 * 
	 * @param fileName Name of the file where it search for methods.
	 */
	public void getFileMethods(String fileName) {
		String startMethodToken;
		String endMethodToken;

		if (qiskit) {
			startMethodToken = "def ";
			endMethodToken = ":";
		} else {
			startMethodToken = "operation ";
			endMethodToken = "{";
		}

		ArrayList<String> fileMethods = new ArrayList<String>();

		String completeFilePath = path + File.separator + fileName;
		File file = new File(completeFilePath);
		BufferedReader reader = null;
		String fileString = "";

		try {
			reader = new BufferedReader(new FileReader(file));
			String line = reader.readLine();
			while (line != null) {
				fileString = fileString + line + System.lineSeparator();
				line = reader.readLine();
			}

			int indexStart = fileString.indexOf(startMethodToken, 0);
			int indexEnd;
			while (indexStart != -1) {

				indexEnd = fileString.indexOf(endMethodToken, indexStart + startMethodToken.length());
				fileMethods.add(fileString.substring(indexStart + startMethodToken.length(), indexEnd));
				indexStart = fileString.indexOf(startMethodToken, indexEnd + endMethodToken.length());

			}

		} catch (IOException e) {
			notifyError(e);
			e.printStackTrace();
		} finally {
			try {
				reader.close();
			} catch (IOException e) {
				notifyError(e);
				e.printStackTrace();
			}
		}
		ArrayList<Mutant> aux = new ArrayList<Mutant>();
		for (Mutant m: mutantList) {
			if (m.getOriginalName().equals(fileName)) {
				aux.add(m);
			}
		}
		observer.updateFileMethods(fileMethods, aux);

	}

	/**
	 * Updates the confidence parameter, and revalues which mutants die.
	 * 
	 * @param confidence New value for confidence parameter.
	 */
	public void updateConfidence(double confidence) {
		this.confidence = confidence;
		if (results != null) {
			getKills();
		}
	}

	/**
	 * Given a mutant list and a set of test, runs all possible combinations of
	 * test/mutant.
	 * 
	 * @param mutantList List of mutants.
	 * @param testSuit   List of test.
	 * @param test       Type of test to be applied.
	 * @param file       Name of the original file.
	 * @param method     Name of the method being tested.
	 * @param timeLimit  Maximum time each test can run for.
	 */
	public void run(ArrayList<Mutant> mutantList, ArrayList<String> testSuit, Test test, String file, String method,
			double timeLimit) {
		try {
			if (timeLimit <= 0) {
				throw new TimeLimitException();
			}
			if (test.getShots() <= 0) {
				throw new ShotsException();
			}
			if (testSuit.size() == 0) {
				throw new EmptyListException("Test list");
			}
			if (file == null || file.equals("")) {
				throw new NullStringException("file");
			}
			if (method == null || file.equals("")) {
				throw new NullStringException("method");
			}
			if (mutantList.size() == 0) {
				throw new EmptyListException("Mutant list");
			}

			if (qiskit) {
				results = new Qiskit().run(mutantList, testSuit, test, method, timeLimit);
			} else {
				results = new QSharp().run(mutantList, testSuit, test, method, timeLimit);
			}

			observer.notifyResults(results);
			getKills();
			observer.notifyTestCaseRunner("Completed\n");
		} catch (TimeLimitException | ShotsException | EmptyListException | NullStringException e) {
			notifyError(e);
		} catch (Exception e) {
			notifyError("Unknown error occurred during execution. Please, check your test and try again.");
		}
	}

	/**
	 * Calculates which mutant dies and which live.
	 */
	private void getKills() {
		ArrayList<ArrayList<Boolean>> kills = new ArrayList<ArrayList<Boolean>>();
		for (ArrayList<TestResult> list : results) {
			ArrayList<Boolean> aux = new ArrayList<Boolean>();
			for (int i = 1; i < list.size(); i++) {
				aux.add(list.get(i).getKill(list.get(0), confidence));
			}
			kills.add(aux);
		}

		observer.updateKills(kills);
	}

}
